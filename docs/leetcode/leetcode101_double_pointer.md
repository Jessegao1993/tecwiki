## 双指针
### 算法解释
贪心算法保证每次操作都是局部最优的，可以保证推导出最后得到的结果是全局最优的。
#### 用处
- 搜索（指向同一数组，遍历方向相反）
- 快慢指针（链表找环路问题）
- 滑动窗口（指向同一数组，遍历方向相同不相交，用于区间搜索）

### Leetcode相关题目
#### 167
##### 题目描述
在一个增序的整数数组里找到两个数，使它们的和为给定值。已知有且只有一对解。
##### 输入输出样例
输入是一个数组（numbers）和一个给定值（target）。输出是两个数的位置，从 1 开始计数。
```
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
```
##### 题解
采用方向相反的双指针来寻找这两个数字，一个初始指向最小的元素，即数组最左边，向右遍历；一个初始指向最大的元素，即数组最右边，向左遍历。如果两个指针指向元素的和等于给定值，那么它们就是我们要的结果。如果两个指针指向元素的和小于给定值，我们把左边的指针右移一位，使得当前的和增加一点。如果两个指针指向元素的和大于给定值，我们把右边的指针左移一位，使得当前的和减少一点。

##### 代码
```
var twoSum = function(numbers, target) {
    let res = []; 
    let sum = 0;
    let r = numbers.length-1;
    let l = 0;
    while(l<r){
      sum = numbers[l]+numbers[r];
      if(sum == target){
        break;
      }
      if(sum<target){
        l++;
      }else{
        r--;
      }
    }
    return res.push(l+1).push(r+1);
}
```
* * *
#### 88
##### 题目描述
给定两个有序数组，把两个数组合并为一个。
##### 输入输出样例
输入是两个数组和它们分别的长度 m 和 n。其中第一个数组的长度被延长至 m + n，多出的
n 位被 0 填补。题目要求把第二个数组归并到第一个数组上，不需要开辟额外空间。
```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: nums1 = [1,2,2,3,5,6]

```
##### 题解
以把两个指针分别放在两个数组的末尾，即 nums1 的m − 1 位和 nums2 的 n − 1 位。每次将较大的那个数字复制到 nums1 的后边，然后向前移动一位。因为我们也要定位 nums1 的末尾，所以我们还需要第三个指针，以便复制。直接利用 m 和 n 当作两个数组的指针，再额外创立一个len 指针，起始位置为 m +n−1。每次向前移动 m 或 n 的时候，也要向前移动 len。
##### 代码
```
var merge = function(nums1, m, nums2, n) {
    let len = m--+n---1;
    while(n>=0){
      if(nums1[m]>nums2[n]){
        nums1[len--] = nums1[m--];
      }else{
        nums1[len--] = nums2[n--];
      }
    }
};
```
* * *
#### 680
##### 题目描述
给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
##### 输入输出样例
输入是一个非空字符串，输出是一个布尔值，表示是否能成为回文字符串。
```
input: "aba"
output: True
```
##### 题解
使用双指针同时从左右两端开始对比每个字符，如果都相同就缩小范围，如果不相同就先看看是否已经删除过一次字符，因为要求最多只能删除一个字符，所以这里如果已经删除过就不符合条件，直接判断为非；否则就删除左或右一个字符看看删除后是否满足继续对比的条件，直到对比完毕。
##### 代码
```
var validPalindrome = function(s) {
    let l = 0;//双指针：左
    let r = s.length-1;//双指针：右
    let remain = 1;
    while(l<r){
      if(s[l]===s[r]){
        l++;
        r--;
      }else{
        if(remain===0){
          return false;
        }
        if(s[l+1]===s[r]&&s[l+2]===s[r-1]){
          remain--;
          l++;
        }else if(s[l]===s[r-1]){
          remain--;
          r--;
        }else{
          return false;
        }
      }
    }
    return true;
};
```